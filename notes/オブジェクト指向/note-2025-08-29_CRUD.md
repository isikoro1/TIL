# 学習ノート 2025-08-29 — オブジェクト指向
java, オブジェクト指向, CRUD処理
Spring Data JPA, Eclipse

オブジェクト指向でのCRUDが曖昧なので、少し整理した。

## ①追加（Create）の場合
~~~java
Todo todo = new Todo();             // ← new で新しい箱を作る
todo.setTitle("牛乳を買う");
todo.setDone(false);

repository.save(todo);              // DBに保存 → 新しいIDがつく（例: ID=1）
~~~
`new`したので、まだIDがない状態 → 新規追加される。

## ②更新（Update）の場合

~~~java
todo.setTitle("豆乳を買う");        // さっき保存したオブジェクトを上書き
todo.setDone(true);

repository.save(todo);             // DBのID=1を探して上書き保存
~~~
もうIDがついている（例:ID=1）から→更新扱いになる。

## ③別のTodoを追加したい場合
~~~java
Todo another = new Todo();          // また newで新しい箱を作る
another.setDone(false);

repository.save(another);           // DBに新規追加　→　ID=2がつく
~~~
`new`すれば別のTodo。DBにはID=2で保存される。

## 疑問点
### この設計だとnewしたら更新できない？
→基本的には 更新できない。
- `new`すると「まだDBに保存されていない新しいオブジェクト」になるので、IDが空。
- `save()`すると「IDが無いから新規追加」と判断される。

ただし、もしIDを手動でセットしたら、Spring Data JPAは「そのIDの行を更新しよう」とする場合がある

~~~java
Todo todo = new Todo();
todo.setId(1L);                             // 既存IDを指定
todo.setTitle("上書きテスト");
repodsitory.save(todo);                     // ID=1を更新（DBに存在する場合）
~~~
    → でもこれは危険（存在しないIDを指定したらINSERTされることもある）ので、普通はやらない

### オブジェクト指向じゃない言語はCRUDできない？
→できる。
- CRUDは「DBの基本操作（Create, Read, Update, Delete）」なので、言語のパラダイム（OOPか手続き型か）は関係ない。
例：
- C言語
    - `INSERT` / `SELECT` / `UPDATE` / `DELETE`をSQL文で書けばCRUD可能
- JavaScript（非OOPでも可）
    - 配列やオブジェクトに対して要素を追加・取得・更新・削除すればCRUDできる

### そもそもOOP(オブジェクト指向)ってなんだ
→  データ（モノ）と処理（ふるまい）をひとまとめにして考える手法。
例:ToDoアプリなら

- データ → `title`, `done`
- 処理 → `完了にする`, `タイトルを変更する`

これを１つの「Todoクラス」にまとめる。
つまり「Todoという"オブジェクト"」を作って扱う。

#### メリット（CRUDとの関係）
1. 扱いやすい（楽になる）
    - 1つの「Todoオブジェクト」を保存・取得・更新・削除できる
    - DBやりストに出し入れする時も、そのままの形で扱える
    - → CRUD処理が自然に書ける
2. 再利用しやすい
    - 「ToDo」を別の機能でもそのまま使える
    - 例:タスク管理アプリでも買い物リストでも
3. 安全性が上がる（セキュリティにも寄与）
    - データを外から直接いじらせず、`setDone(true)`のように「用意したメソッド経由」でしか変更させないようにできる
    - これをカプセル化という
    →　例えば、パスワードを文字列としてそのまま外に見せないで、必ず暗号化メソッドを通すようにする、みたいな実装ができる。

#### 非OOP（手続き型）だとどうなる？
- データと処理がバラバラ
- 例えばC言語だと
~~~c
struct Todo {
    char title[50];
    int done;
};
~~~
更新処理も`updateTodo(&todo, "新しいタイトル");`みたいに、データと処理を別々に定義する。

→書けるけど、複雑なアプリになると管理が大変。

### 最近だと関数型言語に移る動きもあるけど、それぞれのメリット・デメリットはなんだ
#### OOPのメリットとデメリット
メリット
- 実世界のモデル化が得意「Todo」「User」「Order」など
- カプセル化で安全にデータを扱える
- 継承やポリモーフィズムで再利用・拡張しやすい
- UIや業務アプリなど「モノを操作する」設計に自然

デメリット
- クラス設計が複雑になりやすい（肥大化、継承地獄）
- 状態（オブジェクトの中身）が変化するので、予想が難しくなることがある
- マルチスレッドや並列処理で「共有状態」がバグの温床になる

#### 関数型言語（Functional Programming, FP）のメリットとデメリット
メリット
- 不変性（immutable）を重視 → データを「上書き」せず「新しいものを返す」
    → 副作用が少なく、並列処理やテストにつよい
- 小さな純粋関数を組み合わせる → コードの再利用性が高い
- 宣言的でシンプル（「何をしたいか」に集中できる）
    → 例:`map`, `filter`, `reduce`

デメリット
- 学習コストが高い（OOP的な思考から大きく切り替える必要あり）
- 大規模システムでは「データと処理をまとめたい場面」があり、OOP的表現の方が直感的なこともある
- パフォーマンス的にオブジェクト指向の方が有利な場面もある（特に大量の状態管理が必要なUI系）

#### 実務での動き
- サーバーサイドや並列処理 → 関数型がつよい
    - Scala, Elixir, Haslell, F# など
    - 最近はJavaも `Stream API`, `Optional`,`Lambda`で関数型っぽさを取り入れている
- 業務アプリやオブジェクト管理 → OOPが強い
    - Java, C#, Pythonなど
- 現代は両方を取り入れる「マルチパラダイム」が主流
    - JavaScript, Kotlin, Pythonなど → OOPもFPもできる

